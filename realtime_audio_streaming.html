<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶æµå¼TTSéŸ³é¢‘ç”Ÿæˆä¸æ’­æ”¾</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-panel {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .config-section {
            padding: 25px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .config-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .config-group {
            flex: 1;
            min-width: 200px;
        }

        .config-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #495057;
        }

        .config-group input, .config-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .config-group input:focus, .config-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-section {
            padding: 25px;
        }

        .textarea-container {
            position: relative;
            margin-bottom: 20px;
        }

        #textInput {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
        }

        #textInput:focus {
            outline: none;
            border-color: #667eea;
        }

        .char-count {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: #6c757d;
            font-size: 12px;
            background: rgba(255,255,255,0.9);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #c82333;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .status-section {
            padding: 25px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .status-title {
            font-size: 18px;
            font-weight: 600;
            color: #495057;
        }

        .progress-container {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s;
            width: 0%;
        }

        .chunks-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: white;
        }

        .chunk-item {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.3s;
        }

        .chunk-item:last-child {
            border-bottom: none;
        }

        .chunk-item.processing {
            background-color: #fff3cd;
        }

        .chunk-item.completed {
            background-color: #d4edda;
        }

        .chunk-item.error {
            background-color: #f8d7da;
        }

        .chunk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .chunk-index {
            font-weight: 600;
            color: #495057;
        }

        .chunk-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .chunk-status.processing {
            background: #ffc107;
            color: #856404;
        }

        .chunk-status.completed {
            background: #28a745;
            color: white;
        }

        .chunk-status.error {
            background: #dc3545;
            color: white;
        }

        .chunk-text {
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .chunk-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chunk-info {
            font-size: 12px;
            color: #6c757d;
        }

        .play-btn {
            padding: 6px 12px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .play-btn:hover:not(:disabled) {
            background: #138496;
        }

        .play-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .global-audio-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }

        .queue-status {
            background: rgba(0, 123, 255, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #007bff;
            border: 1px solid rgba(0, 123, 255, 0.2);
        }

        .input-hint {
            font-size: 11px;
            color: #6c757d;
            margin-top: 4px;
            font-style: italic;
        }

        .api-key-toggle {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
        }

        .api-key-toggle:hover {
            color: #495057;
        }

        .config-group {
            position: relative;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-slider {
            width: 100px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .processing .chunk-status {
            animation: pulse 1.5s infinite;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .config-row {
                flex-direction: column;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸµ å®æ—¶æµå¼TTSéŸ³é¢‘ç”Ÿæˆ</h1>
            <p>æ™ºèƒ½æ–‡æœ¬åˆ†å‰² Â· å®æ—¶éŸ³é¢‘ç”Ÿæˆ Â· æµå¼æ’­æ”¾ä½“éªŒ</p>
        </div>

        <div class="main-panel">
            <!-- é…ç½®åŒºåŸŸ -->
            <div class="config-section">
                <div class="config-row">
                    <div class="config-group">
                        <label for="serverUrl">æœåŠ¡å™¨åœ°å€</label>
                        <input type="text" id="serverUrl" value="http://152.136.168.63:11996" placeholder="http://152.136.168.63:11996">
                    </div>
                    <div class="config-group">
                        <label for="apiKey">API å¯†é’¥ ğŸ”</label>
                        <input type="password" id="apiKey" value="app-Tkgxa5UdOv1FXeBXyEsFQSi5" placeholder="è¯·è¾“å…¥ API Key" required>
                        <button type="button" class="api-key-toggle" id="toggleApiKey" title="æ˜¾ç¤º/éšè—APIå¯†é’¥">ğŸ‘ï¸</button>
                        <div class="input-hint">ç”¨äºéªŒè¯APIè®¿é—®æƒé™çš„å¯†é’¥</div>
                    </div>
                    <div class="config-group">
                        <label for="audioPath">éŸ³é¢‘æ ·æœ¬é€‰æ‹©</label>
                        <select id="audioPath">
                            <option value="1_oral5.wav">1_oral5.wav</option>
                            <option value="2_oral5.wav">2_oral5.wav</option>
                            <option value="3_oral5.wav">3_oral5.wav</option>
                            <option value="4_oral5.wav">4_oral5.wav</option>
                            <option value="5_oral5.wav">5_oral5.wav</option>
                            <option value="6_oral5.wav">6_oral5.wav</option>
                            <option value="7_oral5.wav">7_oral5.wav</option>
                            <option value="8_oral5.wav">8_oral5.wav</option>
                            <option value="9_oral5.wav">9_oral5.wav</option>
                            <option value="10_oral5.wav">10_oral5.wav</option>
                            <option value="11_oral5.wav">11_oral5.wav</option>
                            <option value="12_oral5.wav">12_oral5.wav</option>
                            <option value="13_oral5.wav">13_oral5.wav</option>
                            <option value="14_oral5.wav">14_oral5.wav</option>
                            <option value="15_oral5.wav">15_oral5.wav</option>
                            <option value="16_oral5.wav">16_oral5.wav</option>
                            <option value="17_oral5.wav">17_oral5.wav</option>
                            <option value="18_oral5.wav">18_oral5.wav</option>
                            <option value="19_oral5.wav">19_oral5.wav</option>
                            <option value="20_oral5.wav">20_oral5.wav</option>
                            <option value="44_1d5fadf24e00d759.wav">44_1d5fadf24e00d759.wav</option>
                            <option value="jay_promptvn.wav">jay_promptvn.wav</option>
                            <option value="sample_prompt.wav" selected>sample_prompt.wav</option>
                            <option value="vo_card_klee_endOfGame_fail_01.wav">vo_card_klee_endOfGame_fail_01.wav</option>
                        </select>
                    </div>
                </div>
                
                <div class="config-row">
                    <div class="config-group">
                        <label for="chunkSize">åˆ†å—å¤§å° <small style="color: #6c757d;">(å·²ç¦ç”¨ï¼Œä»…æŒ‰æ ‡ç‚¹åˆ†å‰²)</small></label>
                        <input type="number" id="chunkSize" value="100" min="20" max="500" disabled title="å½“å‰ç‰ˆæœ¬ä»…æ”¯æŒæŒ‰æ ‡ç‚¹ç¬¦å·åˆ†å‰²æ–‡æœ¬">
                    </div>
                    <div class="config-group">
                        <label for="seed">éšæœºç§å­</label>
                        <input type="number" id="seed" value="8" min="1" max="100">
                    </div>
                    <div class="config-group">
                        <label for="customPunctuation">è‡ªå®šä¹‰åˆ†å‰²ç¬¦</label>
                        <input type="text" id="customPunctuation" placeholder="ä¾‹å¦‚: ï¼šï¼Œã€‚ï¼ï¼Ÿ" title="æ”¯æŒå¤šä¸ªæ ‡ç‚¹ç¬¦å·ï¼Œå¦‚è¾“å…¥'ï¼šï¼Œ'è¡¨ç¤ºé‡åˆ°å†’å·æˆ–é€—å·éƒ½ä¼šåˆ†å‰²ã€‚ç•™ç©ºä½¿ç”¨é»˜è®¤æ ‡ç‚¹ç¬¦å·">
                        <div class="input-hint">æ”¯æŒå¤šæ ‡ç‚¹ç¬¦å·ï¼Œå¦‚"ï¼šï¼Œ"è¡¨ç¤ºé‡åˆ°å†’å·æˆ–é€—å·éƒ½åˆ†å‰²</div>
                    </div>
                </div>
            </div>

            <!-- æ–‡æœ¬è¾“å…¥åŒºåŸŸ -->
            <div class="input-section">
                <div class="textarea-container">
                    <textarea 
                        id="textInput" 
                        placeholder="åœ¨è¿™é‡Œè¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬å†…å®¹...&#10;&#10;æ”¯æŒä¸­æ–‡å’Œè‹±æ–‡ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æŒ‰æ ‡ç‚¹ç¬¦å·åˆ†å‰²æ–‡æœ¬å¹¶é€å—ç”ŸæˆéŸ³é¢‘ã€‚"
                    ></textarea>
                    <div class="char-count">
                        å­—ç¬¦æ•°: <span id="charCount">0</span>
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-primary" id="startBtn">ğŸš€ å¼€å§‹æµå¼ç”Ÿæˆ</button>
                    <button class="btn btn-secondary" id="playAllBtn" disabled>ğŸµ æ’­æ”¾å…¨éƒ¨</button>
                    <button class="btn btn-secondary" id="pauseAllBtn" disabled>â¸ï¸ æš‚åœæ’­æ”¾</button>
                    <button class="btn btn-secondary" id="downloadBtn" disabled>ğŸ’¾ ä¸‹è½½åˆæˆéŸ³é¢‘</button>
                    <button class="btn btn-danger" id="stopBtn" disabled>â¹ï¸åœæ­¢ç”Ÿæˆ</button>
                </div>
            </div>

            <!-- çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="status-section">
                <div class="status-header">
                    <div class="status-title">ğŸ“Š ç”ŸæˆçŠ¶æ€</div>
                    <div id="statusText">ç­‰å¾…å¼€å§‹...</div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>

                <!-- å…¨å±€éŸ³é¢‘æ§åˆ¶ -->
                <div class="global-audio-controls">
                    <div class="volume-control">
                        <label for="volumeSlider">ğŸ”Š éŸ³é‡:</label>
                        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.1" value="0.8">
                        <span id="volumeValue">80%</span>
                    </div>
                    <label>
                        <input type="checkbox" id="autoPlay" checked> è‡ªåŠ¨æ’­æ”¾
                    </label>
                    <div class="queue-status" id="queueStatus" style="display: none;">
                        é˜Ÿåˆ—: <span id="queueCount">0</span>
                    </div>
                </div>

                <!-- éŸ³é¢‘ç‰‡æ®µåˆ—è¡¨ -->
                <div class="chunks-container" id="chunksContainer">
                    <div style="padding: 40px; text-align: center; color: #6c757d;">
                        ğŸµ éŸ³é¢‘ç‰‡æ®µå°†åœ¨è¿™é‡Œæ˜¾ç¤º
                    </div>
                </div>

                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalChunks">0</div>
                        <div class="stat-label">æ€»ç‰‡æ®µæ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="completedChunks">0</div>
                        <div class="stat-label">å·²å®Œæˆ</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalTime">0s</div>
                        <div class="stat-label">æ€»è€—æ—¶</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalSize">0KB</div>
                        <div class="stat-label">éŸ³é¢‘å¤§å°</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StreamingTTSClient {
            constructor() {
                this.isStreaming = false;
                this.eventSource = null;
                this.audioChunks = [];
                this.startTime = null;
                this.totalSize = 0;
                this.currentPlayingIndex = -1;
                this.audioQueue = [];
                this.playbackQueue = []; // æ’­æ”¾é˜Ÿåˆ—ï¼Œå­˜å‚¨ç­‰å¾…æ’­æ”¾çš„ç‰‡æ®µç´¢å¼•
                this.isPlayingSequence = false; // æ˜¯å¦æ­£åœ¨é¡ºåºæ’­æ”¾
                this.globalVolume = 0.8;
                
                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                // é…ç½®å…ƒç´ 
                this.serverUrlInput = document.getElementById('serverUrl');
                this.apiKeyInput = document.getElementById('apiKey');
                this.audioPathInput = document.getElementById('audioPath');
                this.chunkSizeInput = document.getElementById('chunkSize');
                this.seedInput = document.getElementById('seed');
                this.customPunctuationInput = document.getElementById('customPunctuation');
                
                // æ–‡æœ¬è¾“å…¥
                this.textInput = document.getElementById('textInput');
                this.charCountSpan = document.getElementById('charCount');
                
                // æ§åˆ¶æŒ‰é’®
                this.startBtn = document.getElementById('startBtn');
                this.playAllBtn = document.getElementById('playAllBtn');
                this.pauseAllBtn = document.getElementById('pauseAllBtn');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.stopBtn = document.getElementById('stopBtn');
                
                // çŠ¶æ€æ˜¾ç¤º
                this.statusText = document.getElementById('statusText');
                this.progressBar = document.getElementById('progressBar');
                this.chunksContainer = document.getElementById('chunksContainer');
                
                // ç»Ÿè®¡ä¿¡æ¯
                this.totalChunksSpan = document.getElementById('totalChunks');
                this.completedChunksSpan = document.getElementById('completedChunks');
                this.totalTimeSpan = document.getElementById('totalTime');
                this.totalSizeSpan = document.getElementById('totalSize');
                
                // éŸ³é¢‘æ§åˆ¶
                this.volumeSlider = document.getElementById('volumeSlider');
                this.volumeValue = document.getElementById('volumeValue');
                this.autoPlayCheckbox = document.getElementById('autoPlay');
                this.queueStatus = document.getElementById('queueStatus');
                this.queueCount = document.getElementById('queueCount');
            }

            bindEvents() {
                // æ–‡æœ¬è¾“å…¥å­—ç¬¦è®¡æ•°
                this.textInput.addEventListener('input', () => {
                    this.charCountSpan.textContent = this.textInput.value.length;
                });

                // æ§åˆ¶æŒ‰é’®
                this.startBtn.addEventListener('click', () => this.startStreaming());
                this.playAllBtn.addEventListener('click', () => this.playAllChunks());
                this.pauseAllBtn.addEventListener('click', () => this.pauseAllChunks());
                this.downloadBtn.addEventListener('click', () => this.downloadMergedAudio());
                this.stopBtn.addEventListener('click', () => this.stopStreaming());

                // éŸ³é‡æ§åˆ¶
                this.volumeSlider.addEventListener('input', () => {
                    this.globalVolume = parseFloat(this.volumeSlider.value);
                    this.volumeValue.textContent = Math.round(this.globalVolume * 100) + '%';
                    
                    // æ›´æ–°æ‰€æœ‰éŸ³é¢‘å…ƒç´ çš„éŸ³é‡
                    this.audioQueue.forEach(audio => {
                        if (audio.audio) {
                            audio.audio.volume = this.globalVolume;
                        }
                    });
                });

                // åˆå§‹åŒ–å­—ç¬¦è®¡æ•°
                this.charCountSpan.textContent = this.textInput.value.length;
                
                // API Key æ˜¾ç¤º/éšè—åˆ‡æ¢
                const toggleApiKeyBtn = document.getElementById('toggleApiKey');
                toggleApiKeyBtn.addEventListener('click', () => {
                    const apiKeyInput = this.apiKeyInput;
                    if (apiKeyInput.type === 'password') {
                        apiKeyInput.type = 'text';
                        toggleApiKeyBtn.textContent = 'ğŸ™ˆ'; // éšè—å›¾æ ‡
                        toggleApiKeyBtn.title = 'éšè—APIå¯†é’¥';
                    } else {
                        apiKeyInput.type = 'password';
                        toggleApiKeyBtn.textContent = 'ğŸ‘ï¸'; // æ˜¾ç¤ºå›¾æ ‡
                        toggleApiKeyBtn.title = 'æ˜¾ç¤ºAPIå¯†é’¥';
                    }
                });
            }

            async startStreaming() {
                const text = this.textInput.value.trim();
                if (!text) {
                    alert('è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬');
                    return;
                }

                const serverUrl = this.serverUrlInput.value.trim();
                const apiKey = this.apiKeyInput.value.trim();
                const selectedAudioFile = this.audioPathInput.value.trim();
                const audioPath = `/opt/notebook/data/TTS/index-tts-vllm-master/assets/${selectedAudioFile}`;
                
                if (!serverUrl || !selectedAudioFile || !apiKey) {
                    alert('è¯·å¡«å†™æœåŠ¡å™¨åœ°å€ã€APIå¯†é’¥å¹¶é€‰æ‹©éŸ³é¢‘æ ·æœ¬');
                    return;
                }

                // é‡ç½®çŠ¶æ€
                this.resetState();
                this.isStreaming = true;
                this.startTime = Date.now();

                // æ›´æ–°UIçŠ¶æ€
                this.updateButtonStates(true);
                this.statusText.textContent = 'æ­£åœ¨è¿æ¥æœåŠ¡å™¨...';

                try {
                    // å‡†å¤‡è¯·æ±‚æ•°æ®
                    const requestData = {
                        text: text,
                        audio_paths: [audioPath],
                        seed: parseInt(this.seedInput.value) || 8,
                        custom_punctuation: this.customPunctuationInput.value.trim() || null
                    };

                    // å‘èµ·æµå¼è¯·æ±‚
                    const response = await fetch(`${serverUrl}/tts_streaming`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-API-Key': apiKey
                        },
                        body: JSON.stringify(requestData)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    // å¤„ç†æµå¼å“åº”
                    await this.handleStreamResponse(response);

                } catch (error) {
                    console.error('æµå¼è¯·æ±‚å¤±è´¥:', error);
                    let errorMessage = error.message;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯APIå¯†é’¥é”™è¯¯
                    if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                        errorMessage = 'APIå¯†é’¥éªŒè¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥å¯†é’¥æ˜¯å¦æ­£ç¡® ğŸ”‘';
                    } else if (error.message.includes('403') || error.message.includes('Forbidden')) {
                        errorMessage = 'APIè®¿é—®è¢«æ‹’ç»ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½® âš ï¸';
                    }
                    
                    this.statusText.textContent = `âŒ é”™è¯¯: ${errorMessage}`;
                    this.updateButtonStates(false);
                    this.isStreaming = false;
                }
            }

            async handleStreamResponse(response) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                try {
                    while (this.isStreaming) {
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            // å¤„ç†å‰©ä½™ç¼“å†²åŒºæ•°æ®
                            if (buffer.trim()) {
                                await this.processSSEEvent(buffer.trim());
                            }
                            break;
                        }

                        // è§£ç æ•°æ®å—å¹¶æ·»åŠ åˆ°ç¼“å†²åŒº
                        buffer += decoder.decode(value, { stream: true });
                        
                        // å¤„ç†å®Œæ•´çš„SSEäº‹ä»¶ï¼ˆä»¥åŒæ¢è¡Œç¬¦åˆ†å‰²ï¼‰
                        while (buffer.includes('\n\n')) {
                            const eventEnd = buffer.indexOf('\n\n');
                            const eventData = buffer.substring(0, eventEnd);
                            buffer = buffer.substring(eventEnd + 2);
                            
                            await this.processSSEEvent(eventData);
                        }
                    }
                } finally {
                    reader.releaseLock();
                }
            }

            async processSSEEvent(eventData) {
                const lines = eventData.split('\n');
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr && jsonStr !== '') {
                                const data = JSON.parse(jsonStr);
                                await this.handleStreamEvent(data);
                            }
                        } catch (e) {
                            console.warn('è§£æSSEäº‹ä»¶å¤±è´¥:', e.message);
                            console.log('Event data:', eventData.slice(0, 500) + '...');
                        }
                        break; // æ¯ä¸ªäº‹ä»¶åªå¤„ç†ä¸€ä¸ªdataè¡Œ
                    }
                }
            }

            async handleStreamEvent(data) {
                switch (data.type) {
                    case 'start':
                        this.handleStartEvent(data);
                        break;
                    case 'chunk_start':
                        this.handleChunkStartEvent(data);
                        break;
                    case 'audio':
                        await this.handleAudioEvent(data);
                        break;
                    case 'complete':
                        this.handleCompleteEvent(data);
                        break;
                    case 'error':
                        this.handleErrorEvent(data);
                        break;
                }
            }

            handleStartEvent(data) {
                this.statusText.textContent = `å¼€å§‹ç”Ÿæˆ ${data.total_chunks} ä¸ªéŸ³é¢‘ç‰‡æ®µ`;
                this.totalChunksSpan.textContent = data.total_chunks;
                
                // æ¸…ç©ºç‰‡æ®µå®¹å™¨å¹¶åˆ›å»ºç‰‡æ®µå…ƒç´ 
                this.chunksContainer.innerHTML = '';
                
                // é‡ç½®æ’­æ”¾çŠ¶æ€å’Œé˜Ÿåˆ—
                this.currentPlayingIndex = -1;
                this.isPlayingSequence = false;
                this.playbackQueue = [];
                
                data.chunks.forEach((chunkText, index) => {
                    this.createChunkElement(index, chunkText);
                });
            }

            handleChunkStartEvent(data) {
                this.statusText.textContent = `æ­£åœ¨ç”Ÿæˆç‰‡æ®µ ${data.chunk_index + 1}/${data.total_chunks}`;
                this.updateChunkStatus(data.chunk_index, 'processing', 'å¤„ç†ä¸­');
            }

            async handleAudioEvent(data) {
                const chunkIndex = data.chunk_index;
                const audioB64 = data.data;
                const processingTime = data.processing_time;
                const size = data.size;

                try {
                    // è§£ç éŸ³é¢‘æ•°æ®
                    const audioBytes = this.base64ToArrayBuffer(audioB64);
                    const audioBlob = new Blob([audioBytes], { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(audioBlob);

                    // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
                    const audio = new Audio(audioUrl);
                    audio.volume = this.globalVolume;

                    // å­˜å‚¨éŸ³é¢‘ä¿¡æ¯
                    this.audioQueue[chunkIndex] = {
                        audio: audio,
                        blob: audioBlob,
                        url: audioUrl,
                        size: size,
                        processingTime: processingTime
                    };

                    // æ›´æ–°ç‰‡æ®µçŠ¶æ€
                    this.updateChunkStatus(chunkIndex, 'completed', 'å·²å®Œæˆ');
                    this.updateChunkInfo(chunkIndex, size, processingTime);

                    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                    this.totalSize += size;
                    this.completedChunksSpan.textContent = parseInt(this.completedChunksSpan.textContent) + 1;
                    this.totalSizeSpan.textContent = (this.totalSize / 1024).toFixed(1) + 'KB';

                    // æ›´æ–°è¿›åº¦
                    const totalChunks = parseInt(this.totalChunksSpan.textContent);
                    const completedChunks = parseInt(this.completedChunksSpan.textContent);
                    const progress = (completedChunks / totalChunks) * 100;
                    this.progressBar.style.width = progress + '%';

                    // è‡ªåŠ¨æ’­æ”¾é˜Ÿåˆ—ç®¡ç†
                    if (this.autoPlayCheckbox.checked) {
                        console.log(`[AutoPlay] ç‰‡æ®µ ${chunkIndex} ç”Ÿæˆå®Œæˆï¼Œå½“å‰æ’­æ”¾: ${this.currentPlayingIndex}, æ’­æ”¾åºåˆ—: ${this.isPlayingSequence}, é˜Ÿåˆ—: [${this.playbackQueue.join(',')}]`);
                        this.handleAutoPlay(chunkIndex);
                    }

                } catch (error) {
                    console.error('å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
                    this.updateChunkStatus(chunkIndex, 'error', 'é”™è¯¯');
                }
            }

            handleCompleteEvent(data) {
                this.statusText.textContent = `âœ… ç”Ÿæˆå®Œæˆï¼å…± ${data.total_chunks} ä¸ªç‰‡æ®µ`;
                this.updateButtonStates(false);
                this.playAllBtn.disabled = false;
                this.downloadBtn.disabled = false; // å¯ç”¨ä¸‹è½½æŒ‰é’®
                this.isStreaming = false;

                // æ›´æ–°æ€»è€—æ—¶
                const totalTime = (Date.now() - this.startTime) / 1000;
                this.totalTimeSpan.textContent = totalTime.toFixed(1) + 's';
            }

            handleErrorEvent(data) {
                console.error('éŸ³é¢‘ç”Ÿæˆé”™è¯¯:', data);
                this.updateChunkStatus(data.chunk_index, 'error', 'é”™è¯¯');
                this.statusText.textContent = `âŒ ç‰‡æ®µ ${data.chunk_index + 1} ç”Ÿæˆå¤±è´¥`;
            }

            createChunkElement(index, text) {
                const chunkDiv = document.createElement('div');
                chunkDiv.className = 'chunk-item';
                chunkDiv.id = `chunk-${index}`;

                chunkDiv.innerHTML = `
                    <div class="chunk-header">
                        <div class="chunk-index">ç‰‡æ®µ ${index + 1}</div>
                        <div class="chunk-status" id="status-${index}">ç­‰å¾…ä¸­</div>
                    </div>
                    <div class="chunk-text">${text}</div>
                    <div class="chunk-controls">
                        <button class="play-btn" id="play-${index}" onclick="client.playChunk(${index})" disabled>
                            â–¶ï¸ æ’­æ”¾
                        </button>
                        <div class="chunk-info" id="info-${index}">-</div>
                    </div>
                `;

                this.chunksContainer.appendChild(chunkDiv);
            }

            updateChunkStatus(index, status, text) {
                const chunkElement = document.getElementById(`chunk-${index}`);
                const statusElement = document.getElementById(`status-${index}`);

                if (chunkElement && statusElement) {
                    // æ›´æ–°ç±»å
                    chunkElement.className = `chunk-item ${status}`;
                    statusElement.className = `chunk-status ${status}`;
                    statusElement.textContent = text;

                    // å¦‚æœå®Œæˆï¼Œå¯ç”¨æ’­æ”¾æŒ‰é’®
                    if (status === 'completed') {
                        const playBtn = document.getElementById(`play-${index}`);
                        if (playBtn) {
                            playBtn.disabled = false;
                        }
                    }
                }
            }

            updateChunkInfo(index, size, processingTime) {
                const infoElement = document.getElementById(`info-${index}`);
                if (infoElement) {
                    infoElement.textContent = `${(size / 1024).toFixed(1)}KB Â· ${processingTime.toFixed(2)}s`;
                }
            }

            playChunk(index) {
                const audioInfo = this.audioQueue[index];
                if (!audioInfo || !audioInfo.audio) {
                    return;
                }

                // åœæ­¢å…¶ä»–æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ï¼ˆä½†ä¸é‡ç½®æ’­æ”¾çŠ¶æ€ï¼‰
                this.pauseAllAudioOnly();

                // æ’­æ”¾å½“å‰éŸ³é¢‘
                this.currentPlayingIndex = index;
                
                // æ¸…ç†ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
                audioInfo.audio.onended = null;
                
                // é‡æ–°ç»‘å®šæ’­æ”¾ç»“æŸäº‹ä»¶
                audioInfo.audio.onended = () => {
                    this.onChunkPlaybackComplete();
                };
                
                audioInfo.audio.play().catch(error => {
                    console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error);
                    this.onChunkPlaybackComplete();
                });
            }

            // å¤„ç†éŸ³é¢‘æ’­æ”¾å®Œæˆ
            onChunkPlaybackComplete() {
                console.log(`[AutoPlay] æ’­æ”¾å®Œæˆï¼Œé˜Ÿåˆ—é•¿åº¦: ${this.playbackQueue.length}, æ˜¯å¦æµå¼ç”Ÿæˆ: ${this.isStreaming}`);
                this.currentPlayingIndex = -1;
                
                // å¦‚æœå¯ç”¨äº†è‡ªåŠ¨æ’­æ”¾ä¸”æ­£åœ¨é¡ºåºæ’­æ”¾
                if (this.isPlayingSequence && this.autoPlayCheckbox.checked) {
                    if (this.playbackQueue.length > 0) {
                        // æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªç‰‡æ®µ
                        const nextIndex = this.getNextChunkToPlay();
                        if (nextIndex !== -1) {
                            console.log(`[AutoPlay] ç»§ç»­æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ç‰‡æ®µ ${nextIndex}ï¼Œå½“å‰é˜Ÿåˆ—: [${this.playbackQueue.join(',')}]`);
                            const indexInQueue = this.playbackQueue.indexOf(nextIndex);
                            console.log(`[AutoPlay] ä»é˜Ÿåˆ—ä¸­ç§»é™¤ç‰‡æ®µ ${nextIndex}ï¼Œä½ç½®: ${indexInQueue}`);
                            this.playbackQueue.splice(indexInQueue, 1);
                            console.log(`[AutoPlay] ç§»é™¤åé˜Ÿåˆ—: [${this.playbackQueue.join(',')}]`);
                            this.updateQueueStatus();
                            setTimeout(() => this.playChunk(nextIndex), 100);
                        }
                    } else {
                        // é˜Ÿåˆ—ä¸ºç©ºï¼Œæ£€æŸ¥æ˜¯å¦è¿˜æœ‰æœªç”Ÿæˆçš„ç‰‡æ®µéœ€è¦ç­‰å¾…
                        if (!this.isStreaming) {
                            // ä¸åœ¨ç”Ÿæˆä¸­ï¼Œç»“æŸæ’­æ”¾åºåˆ—
                            console.log(`[AutoPlay] ç”Ÿæˆå®Œæˆä¸”é˜Ÿåˆ—ä¸ºç©ºï¼Œç»“æŸæ’­æ”¾åºåˆ— ğŸ‰`);
                            this.isPlayingSequence = false;
                            this.updateQueueStatus();
                        } else {
                            // è¿˜åœ¨ç”Ÿæˆä¸­ï¼Œä¿æŒæ’­æ”¾åºåˆ—çŠ¶æ€ï¼Œç­‰å¾…æ–°çš„ç‰‡æ®µ
                            console.log(`[AutoPlay] è¿˜åœ¨ç”Ÿæˆä¸­ï¼Œç­‰å¾…æ–°ç‰‡æ®µ â³`);
                            this.updateQueueStatus();
                        }
                    }
                } else {
                    // ä¸æ˜¯è‡ªåŠ¨æ’­æ”¾æ¨¡å¼æˆ–ä¸åœ¨æ’­æ”¾åºåˆ—ä¸­
                    this.isPlayingSequence = false;
                    this.updateQueueStatus();
                }
            }

            // å¤„ç†è‡ªåŠ¨æ’­æ”¾é€»è¾‘
            handleAutoPlay(chunkIndex) {
                console.log(`[AutoPlay] å¤„ç†ç‰‡æ®µ ${chunkIndex}ï¼Œå½“å‰çŠ¶æ€: æ’­æ”¾=${this.currentPlayingIndex}, åºåˆ—=${this.isPlayingSequence}`);
                
                if (this.currentPlayingIndex === -1 && !this.isPlayingSequence) {
                    // å½“å‰æ²¡æœ‰éŸ³é¢‘åœ¨æ’­æ”¾ä¸”ä¸åœ¨æ’­æ”¾åºåˆ—ä¸­ï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥å¼€å§‹æ’­æ”¾
                    if (chunkIndex === 0 || !this.shouldWaitForEarlierChunks(chunkIndex)) {
                        // å¦‚æœæ˜¯ç¬¬ä¸€ä¸ªç‰‡æ®µï¼Œæˆ–è€…å‰é¢çš„ç‰‡æ®µéƒ½å·²å‡†å¤‡å¥½/ä¸å­˜åœ¨ï¼Œç›´æ¥æ’­æ”¾
                        console.log(`[AutoPlay] ç›´æ¥æ’­æ”¾ç‰‡æ®µ ${chunkIndex}`);
                        this.playChunk(chunkIndex);
                        this.isPlayingSequence = true;
                    } else {
                        // å¦åˆ™åŠ å…¥é˜Ÿåˆ—ç­‰å¾…
                        console.log(`[AutoPlay] ç‰‡æ®µ ${chunkIndex} éœ€ç­‰å¾…æ›´æ—©ç‰‡æ®µï¼ŒåŠ å…¥é˜Ÿåˆ—`);
                        this.addToPlaybackQueue(chunkIndex);
                    }
                } else {
                    // æœ‰éŸ³é¢‘åœ¨æ’­æ”¾æˆ–æ­£åœ¨æ’­æ”¾åºåˆ—ä¸­ï¼ŒåŠ å…¥æ’­æ”¾é˜Ÿåˆ—
                    console.log(`[AutoPlay] ç‰‡æ®µ ${chunkIndex} åŠ å…¥æ’­æ”¾é˜Ÿåˆ—`);
                    this.addToPlaybackQueue(chunkIndex);
                    
                    // å¦‚æœå½“å‰æ²¡æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ï¼Œä½†æœ‰é˜Ÿåˆ—ï¼Œå°è¯•æ’­æ”¾é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ª
                    if (this.currentPlayingIndex === -1 && this.playbackQueue.length > 0) {
                        const nextIndex = this.getNextChunkToPlay();
                        if (nextIndex !== -1) {
                            console.log(`[AutoPlay] ä»é˜Ÿåˆ—æ’­æ”¾ç‰‡æ®µ ${nextIndex}`);
                            this.playbackQueue.splice(this.playbackQueue.indexOf(nextIndex), 1);
                            this.playChunk(nextIndex);
                        }
                    }
                }
            }

            // æ£€æŸ¥æ˜¯å¦åº”è¯¥ç­‰å¾…æ›´æ—©çš„ç‰‡æ®µ
            shouldWaitForEarlierChunks(chunkIndex) {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ—©çš„ç‰‡æ®µè¿˜æ²¡æœ‰ç”Ÿæˆå®Œæˆ
                for (let i = 0; i < chunkIndex; i++) {
                    // å¦‚æœæŸä¸ªæ›´æ—©çš„ç‰‡æ®µå­˜åœ¨ä½†è¿˜æ²¡æœ‰éŸ³é¢‘æ•°æ®ï¼Œéœ€è¦ç­‰å¾…
                    const chunkElement = document.getElementById(`chunk-${i}`);
                    if (chunkElement && !this.audioQueue[i]) {
                        return true;
                    }
                }
                return false;
            }

            // è·å–ä¸‹ä¸€ä¸ªåº”è¯¥æ’­æ”¾çš„ç‰‡æ®µ
            getNextChunkToPlay() {
                if (this.playbackQueue.length === 0) return -1;
                
                // æ‰¾åˆ°é˜Ÿåˆ—ä¸­æœ€å°çš„ç´¢å¼•ï¼ˆæœ€æ—©çš„ç‰‡æ®µï¼‰
                return Math.min(...this.playbackQueue);
            }

            // æ·»åŠ åˆ°æ’­æ”¾é˜Ÿåˆ—
            addToPlaybackQueue(chunkIndex) {
                if (!this.playbackQueue.includes(chunkIndex)) {
                    // æŒ‰é¡ºåºæ’å…¥é˜Ÿåˆ—ï¼Œç¡®ä¿æ’­æ”¾é¡ºåºæ­£ç¡®
                    let insertIndex = 0;
                    while (insertIndex < this.playbackQueue.length && this.playbackQueue[insertIndex] < chunkIndex) {
                        insertIndex++;
                    }
                    this.playbackQueue.splice(insertIndex, 0, chunkIndex);
                    this.updateQueueStatus();
                }
            }

            // æ›´æ–°é˜Ÿåˆ—çŠ¶æ€æ˜¾ç¤º
            updateQueueStatus() {
                if (this.playbackQueue.length > 0) {
                    this.queueStatus.style.display = 'block';
                    this.queueCount.textContent = this.playbackQueue.length;
                } else {
                    this.queueStatus.style.display = 'none';
                }
            }

            playAllChunks() {
                if (this.audioQueue.length === 0) {
                    return;
                }

                this.pauseAllChunks();
                
                // é‡ç½®æ’­æ”¾é˜Ÿåˆ—
                this.playbackQueue = [];
                this.isPlayingSequence = true;
                
                // æ„å»ºå®Œæ•´çš„æ’­æ”¾é˜Ÿåˆ—ï¼Œä»ç¬¬äºŒä¸ªå¼€å§‹ï¼ˆç¬¬ä¸€ä¸ªä¼šç›´æ¥æ’­æ”¾ï¼‰
                for (let i = 1; i < this.audioQueue.length; i++) {
                    if (this.audioQueue[i]) {
                        this.playbackQueue.push(i);
                    }
                }
                
                this.updateQueueStatus();
                
                // å¼€å§‹æ’­æ”¾ç¬¬ä¸€ä¸ª
                if (this.audioQueue[0]) {
                    this.playChunk(0);
                } else {
                    // å¦‚æœç¬¬ä¸€ä¸ªç‰‡æ®µä¸å­˜åœ¨ï¼Œä»é˜Ÿåˆ—ä¸­æ’­æ”¾ç¬¬ä¸€ä¸ªå¯ç”¨çš„
                    if (this.playbackQueue.length > 0) {
                        const firstIndex = this.playbackQueue.shift();
                        this.updateQueueStatus();
                        this.playChunk(firstIndex);
                    }
                }
            }

            // åªåœæ­¢éŸ³é¢‘æ’­æ”¾ï¼Œä¸é‡ç½®æ’­æ”¾çŠ¶æ€ï¼ˆç”¨äºåˆ‡æ¢éŸ³é¢‘æ—¶ï¼‰
            pauseAllAudioOnly() {
                this.audioQueue.forEach((audioInfo, index) => {
                    if (audioInfo && audioInfo.audio) {
                        audioInfo.audio.pause();
                        audioInfo.audio.currentTime = 0;
                        // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…æ’­æ”¾å®Œæˆäº‹ä»¶è§¦å‘
                        audioInfo.audio.onended = null;
                    }
                });
            }

            // åœæ­¢æ‰€æœ‰éŸ³é¢‘å¹¶é‡ç½®æ’­æ”¾çŠ¶æ€ï¼ˆç”¨äºå®Œå…¨åœæ­¢æ’­æ”¾ï¼‰
            pauseAllChunks() {
                this.pauseAllAudioOnly();
                
                // é‡ç½®æ’­æ”¾çŠ¶æ€
                this.currentPlayingIndex = -1;
                this.isPlayingSequence = false;
                this.playbackQueue = [];
                this.updateQueueStatus();
            }

            stopStreaming() {
                this.isStreaming = false;
                this.statusText.textContent = 'â¹ï¸ å·²åœæ­¢ç”Ÿæˆ';
                this.updateButtonStates(false);
                this.pauseAllChunks();
            }

            resetState() {
                this.audioChunks = [];
                this.audioQueue = [];
                this.totalSize = 0;
                this.currentPlayingIndex = -1;
                
                // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
                this.totalChunksSpan.textContent = '0';
                this.completedChunksSpan.textContent = '0';
                this.totalTimeSpan.textContent = '0s';
                this.totalSizeSpan.textContent = '0KB';
                
                // é‡ç½®è¿›åº¦æ¡
                this.progressBar.style.width = '0%';
                
                // é‡ç½®ä¸‹è½½æŒ‰é’®
                this.downloadBtn.disabled = true;
                this.downloadBtn.textContent = 'ğŸ’¾ ä¸‹è½½åˆæˆéŸ³é¢‘';
                
                // æ¸…ç©ºç‰‡æ®µå®¹å™¨
                this.chunksContainer.innerHTML = '<div style="padding: 40px; text-align: center; color: #6c757d;">ğŸµ éŸ³é¢‘ç‰‡æ®µå°†åœ¨è¿™é‡Œæ˜¾ç¤º</div>';
            }

            // ä¸‹è½½åˆå¹¶åçš„éŸ³é¢‘
            async downloadMergedAudio() {
                if (this.audioQueue.length === 0) {
                    alert('æ²¡æœ‰å¯ä¸‹è½½çš„éŸ³é¢‘ç‰‡æ®µ');
                    return;
                }

                try {
                    this.downloadBtn.disabled = true;
                    this.downloadBtn.textContent = 'ğŸ”„ åˆå¹¶ä¸­...';
                    
                    // è·å–æ‰€æœ‰æœ‰æ•ˆçš„éŸ³é¢‘ç‰‡æ®µ
                    const validAudioChunks = [];
                    for (let i = 0; i < this.audioQueue.length; i++) {
                        if (this.audioQueue[i] && this.audioQueue[i].blob) {
                            validAudioChunks.push(this.audioQueue[i].blob);
                        }
                    }

                    if (validAudioChunks.length === 0) {
                        alert('æ²¡æœ‰æœ‰æ•ˆçš„éŸ³é¢‘ç‰‡æ®µå¯ä¸‹è½½');
                        return;
                    }

                    // åˆå¹¶éŸ³é¢‘æ•°æ®
                    const mergedAudio = await this.mergeAudioBlobs(validAudioChunks);
                    
                    // åˆ›å»ºä¸‹è½½é“¾æ¥
                    const url = URL.createObjectURL(mergedAudio);
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const filename = `tts_merged_audio_${timestamp}.wav`;
                    
                    // è§¦å‘ä¸‹è½½
                    const downloadLink = document.createElement('a');
                    downloadLink.href = url;
                    downloadLink.download = filename;
                    downloadLink.style.display = 'none';
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    // æ¸…ç†ä¸´æ—¶URL
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    
                    this.statusText.textContent = `âœ… éŸ³é¢‘ä¸‹è½½å®Œæˆ: ${filename}`;
                    
                } catch (error) {
                    console.error('ä¸‹è½½éŸ³é¢‘å¤±è´¥:', error);
                    alert('ä¸‹è½½éŸ³é¢‘æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message);
                } finally {
                    this.downloadBtn.disabled = false;
                    this.downloadBtn.textContent = 'ğŸ’¾ ä¸‹è½½åˆæˆéŸ³é¢‘';
                }
            }

            // åˆå¹¶å¤šä¸ªéŸ³é¢‘Blob
            async mergeAudioBlobs(audioBlobs) {
                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffers = [];
                
                // è§£ç æ‰€æœ‰éŸ³é¢‘æ•°æ®
                for (const blob of audioBlobs) {
                    try {
                        const arrayBuffer = await blob.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        audioBuffers.push(audioBuffer);
                    } catch (error) {
                        console.warn('è§£ç éŸ³é¢‘å¤±è´¥ï¼Œè·³è¿‡è¯¥ç‰‡æ®µ:', error);
                    }
                }

                if (audioBuffers.length === 0) {
                    throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„éŸ³é¢‘æ•°æ®å¯åˆå¹¶');
                }

                // è®¡ç®—åˆå¹¶åçš„æ€»é•¿åº¦
                const totalLength = audioBuffers.reduce((sum, buffer) => sum + buffer.length, 0);
                const sampleRate = audioBuffers[0].sampleRate;
                const numberOfChannels = audioBuffers[0].numberOfChannels;

                // åˆ›å»ºåˆå¹¶åçš„éŸ³é¢‘ç¼“å†²åŒº
                const mergedBuffer = audioContext.createBuffer(numberOfChannels, totalLength, sampleRate);

                // åˆå¹¶éŸ³é¢‘æ•°æ®
                let offset = 0;
                for (const buffer of audioBuffers) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const channelData = buffer.getChannelData(channel);
                        mergedBuffer.getChannelData(channel).set(channelData, offset);
                    }
                    offset += buffer.length;
                }

                // å°†éŸ³é¢‘ç¼“å†²åŒºè½¬æ¢ä¸ºWAVæ ¼å¼çš„Blob
                const wavBlob = this.audioBufferToWav(mergedBuffer);
                
                // å…³é—­éŸ³é¢‘ä¸Šä¸‹æ–‡
                await audioContext.close();
                
                return wavBlob;
            }

            // å°†AudioBufferè½¬æ¢ä¸ºWAVæ ¼å¼çš„Blob
            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const bytesPerSample = 2; // 16-bit
                const blockAlign = numberOfChannels * bytesPerSample;
                const byteRate = sampleRate * blockAlign;
                const dataSize = length * blockAlign;
                const bufferSize = 44 + dataSize;

                const arrayBuffer = new ArrayBuffer(bufferSize);
                const view = new DataView(arrayBuffer);

                // WAVæ–‡ä»¶å¤´
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                // RIFFæ ‡è¯†ç¬¦
                writeString(0, 'RIFF');
                view.setUint32(4, bufferSize - 8, true);
                writeString(8, 'WAVE');

                // fmtå­å—
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // å­å—å¤§å°
                view.setUint16(20, 1, true); // éŸ³é¢‘æ ¼å¼ (PCM)
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, 16, true); // ä½æ·±åº¦

                // dataå­å—
                writeString(36, 'data');
                view.setUint32(40, dataSize, true);

                // éŸ³é¢‘æ•°æ®
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                        view.setInt16(offset, intSample, true);
                        offset += 2;
                    }
                }

                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            updateButtonStates(isStreaming) {
                this.startBtn.disabled = isStreaming;
                this.stopBtn.disabled = !isStreaming;
                this.playAllBtn.disabled = isStreaming;
                this.pauseAllBtn.disabled = isStreaming;
                this.downloadBtn.disabled = isStreaming; // ç”Ÿæˆè¿‡ç¨‹ä¸­ç¦ç”¨ä¸‹è½½
            }

            base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
        }

        // åˆå§‹åŒ–å®¢æˆ·ç«¯
        const client = new StreamingTTSClient();

        // ç¤ºä¾‹æ–‡æœ¬
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('textInput').value = `å„ä½åª’ä½“æœ‹å‹ã€å¸‚æ°‘ä»£è¡¨ï¼šâ€‹
å¤§å®¶ä¸Šåˆå¥½ï¼ä»Šå¤©ï¼Œæˆ‘ä»¬æ€€ç€æ¬£å–œçš„å¿ƒæƒ…ï¼Œå‘ç¤¾ä¼šæ­£å¼å®£å¸ƒæˆ‘å¸‚æ™ºæ…§äº¤é€šç³»ç»Ÿå…¨é¢å‡çº§ä¸Šçº¿ã€‚è¿™æ˜¯æˆ‘å¸‚è½å® â€œæ™ºæ…§åŸå¸‚â€ å»ºè®¾è§„åˆ’çš„å…³é”®ä¸€æ­¥ï¼Œä¹Ÿæ˜¯è§£å†³å¸‚æ°‘å‡ºè¡Œç—›ç‚¹ã€æå‡åŸå¸‚æ²»ç†æ•ˆèƒ½çš„é‡è¦ä¸¾æªã€‚â€‹
æ­¤æ¬¡å‡çº§å†æ—¶ 18 ä¸ªæœˆï¼Œç”±å¸‚äº¤é€šå±€è”åˆç§‘æŠ€ä¼ä¸šå…±åŒç ”å‘ï¼Œæ•´åˆäº†å¤§æ•°æ®ã€äººå·¥æ™ºèƒ½ã€5G ç­‰å‰æ²¿æŠ€æœ¯ï¼Œå½¢æˆ â€œä¸€å¹³å°ã€å¤šåœºæ™¯â€ çš„æœåŠ¡ä½“ç³»ã€‚å¹³å°æ ¸å¿ƒåŠŸèƒ½æ¶µç›–ä¸‰å¤§æ¿å—ï¼šä¸€æ˜¯å®æ—¶è·¯å†µæ™ºèƒ½é¢„è­¦ï¼Œé€šè¿‡éå¸ƒåŸåŒºçš„ 500 ä½™å¤„æ™ºèƒ½ç›‘æµ‹è®¾å¤‡ï¼Œå®æ—¶æ•æ‰äº¤é€šæ‹¥å µã€äº‹æ•…ç­‰å¼‚å¸¸æƒ…å†µï¼Œ10 ç§’å†…æ¨é€é¢„è­¦ä¿¡æ¯è‡³å‘¨è¾¹è½¦è¾†ï¼›äºŒæ˜¯å…¬å…±äº¤é€šç²¾å‡†è°ƒåº¦ï¼Œå¸‚æ°‘é€šè¿‡ â€œåŸå¸‚å‡ºè¡Œâ€ APPï¼Œå¯æŸ¥è¯¢å…¬äº¤ã€åœ°é“çš„å®æ—¶ä½ç½®ï¼Œé¢„ä¼°åˆ°ç«™æ—¶é—´è¯¯å·®ç¼©å°è‡³ 1 åˆ†é’Ÿå†…ï¼›ä¸‰æ˜¯åœè½¦èµ„æºé«˜æ•ˆåˆ©ç”¨ï¼Œç³»ç»Ÿæ•´åˆå…¨å¸‚ 2.3 ä¸‡ä¸ªå…¬å…±åœè½¦ä½ä¿¡æ¯ï¼Œæ”¯æŒåœ¨çº¿é¢„çº¦ã€æ— æ„Ÿæ”¯ä»˜ï¼Œæœ‰æ•ˆç¼“è§£ â€œåœè½¦éš¾â€ é—®é¢˜ã€‚â€‹
è¯•è¿è¡Œä¸€ä¸ªæœˆä»¥æ¥ï¼Œç³»ç»Ÿå·²è¦†ç›–ä¸»åŸåŒº 80% çš„äº¤é€šè·¯ç½‘ï¼Œé«˜å³°æ—¶æ®µé“è·¯é€šè¡Œæ•ˆç‡æå‡ 25%ï¼Œå…¬å…±äº¤é€šå‡†ç‚¹ç‡æé«˜è‡³ 98%ï¼Œå¸‚æ°‘æ»¡æ„åº¦è¾¾ 92%ã€‚ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†é€æ­¥æ‹“å±•å¿åŸŸäº¤é€šè¦†ç›–èŒƒå›´ï¼Œè®¡åˆ’å¹´å†…æ–°å¢ 100 å¤„æ™ºèƒ½è¿‡è¡—è®¾å¤‡ã€50 æ¡å®šåˆ¶å…¬äº¤è·¯çº¿ï¼ŒæŒç»­ä¼˜åŒ–æ™ºæ…§äº¤é€šæœåŠ¡ä½“éªŒã€‚â€‹
äº¤é€šæ˜¯åŸå¸‚çš„ â€œè¡€è„‰â€ï¼Œæ™ºæ…§äº¤é€šç³»ç»Ÿçš„å‡çº§ï¼Œæ—¢æ˜¯æå‡åŸå¸‚ç«äº‰åŠ›çš„å¿…ç„¶é€‰æ‹©ï¼Œæ›´æ˜¯ä¸ºå¸‚æ°‘åˆ›é€ ç¾å¥½ç”Ÿæ´»çš„å…·ä½“å®è·µã€‚æˆ‘ä»¬æœŸå¾…ä¸ç¤¾ä¼šå„ç•Œå…±åŒç›‘ç£ã€å»ºè¨€çŒ®ç­–ï¼Œè®©æ™ºæ…§äº¤é€šçœŸæ­£æˆä¸ºä¾¿æ°‘ã€åˆ©æ°‘ã€æƒ æ°‘çš„æ°‘ç”Ÿå·¥ç¨‹ï¼â€‹
è°¢è°¢å¤§å®¶ï¼`;
            
            // æ›´æ–°å­—ç¬¦è®¡æ•°
            client.charCountSpan.textContent = document.getElementById('textInput').value.length;
        });
    </script>
</body>
</html>
